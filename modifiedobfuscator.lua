--// NotPr0's Obfuscator Module
--// This is edited for RBXLua (replaced loadstring)

local customVarName1 = "lol" -- "NotPr0"
-- Default Settings
local comment1 = "something" -- "Obfuscated with NotPr0's Obfuscator"


--local Script=[[print"test"]] -- Here you should change to your script

--a=Script;

function Obfuscate1(b,cstm,cmm)
	local customVarName = cstm or customVarName1
	local comment = cmm or comment1
	local c="function "..customVarName.."IllIlllIllIlllIlllIlllIll1("..customVarName.."IllIlllIllIllIll1) if("..customVarName.."IllIlllIllIllIll1==(((((312 + 456)-456)*1789)/1789)+312))then return not true end if ("..customVarName.."IllIlllIllIllIll1==(((((968 + 670)-670)*3315)/3315)+968)) then return not false end end; "
	local d=c;
	local e=" "
	local f={""..customVarName.."IllIllIllIllI",""..customVarName.."IIlllIIlllIIlllIIlllII",""..customVarName.."IIllllIIllll"}
	local g=[[local ]]..customVarName..[[IlIlIlIlIlIlIlIlII = {]]
	local ls = [==[(function(...)local b=(function(...)local c={}local d={}local e={}local f={}local g={}local h={}local i=8;local function j(k)if not k then error("assertion failed!")end end;function c:make_getS(l)local m=l;return function()if not m then return nil end;local n=m;m=nil;return n end end;function c:make_getF(o)local p=512;local q=1;return function()local l=o:sub(q,q+p-1)q=math.min(#o+1,q+p)return l end end;function c:init(r,n)if not r then return end;local s={}s.reader=r;s.data=n or""s.name=name;if not n or n==""then s.n=0 else s.n=#n end;s.p=0;return s end;function c:fill(s)local l=s.reader()s.data=l;if not l or l==""then return"EOZ"end;s.n,s.p=#l-1,1;return string.sub(l,1,1)end;function c:zgetc(s)local t,u=s.n,s.p+1;if t>0 then s.n,s.p=t-1,u;return string.sub(s.data,u,u)else return self:fill(s)end end;e.RESERVED="TK_AND and\nTK_BREAK break\nTK_DO do\nTK_ELSE else\nTK_ELSEIF elseif\nTK_END end\nTK_FALSE false\nTK_FOR for\nTK_FUNCTION function\nTK_IF if\nTK_IN in\nTK_LOCAL local\nTK_NIL nil\nTK_NOT not\nTK_OR or\nTK_REPEAT repeat\nTK_RETURN return\nTK_THEN then\nTK_TRUE true\nTK_UNTIL until\nTK_WHILE while\nTK_CONCAT ..\nTK_DOTS ...\nTK_EQ ==\nTK_GE >=\nTK_LE <=\nTK_NE ~=\nTK_NAME <name>\nTK_NUMBER <number>\nTK_STRING <string>\nTK_EOS <eof>"e.MAXSRC=80;e.MAX_INT=2147483645;e.LUA_QS="'%s'"e.LUA_COMPAT_LSTR=1;function e:init()local v,w={},{}for y in string.gmatch(self.RESERVED,"[^\n]+")do local z,z,A,B=string.find(y,"(%S+)%s+(%S+)")v[A]=B;w[B]=A end;self.tokens=v;self.enums=w end;function e:chunkid(o,C)local D;local E=string.sub(o,1,1)if E=="="then D=string.sub(o,2,C)else if E=="@"then o=string.sub(o,2)C=C-#" '...' "local F=#o;D=""if F>C then o=string.sub(o,1+F-C)D=D.."..."end;D=D..o else local G=string.find(o,"[\n\r]")G=G and G-1 or#o;C=C-#" [string \"...\"] "if G>C then G=C end;D="[string \""if G<#o then D=D..string.sub(o,1,G).."..."else D=D..o end;D=D.."\"]"end end;return D end;function e:token2str(H,I)if string.sub(I,1,3)~="TK_"then if string.find(I,"%c")then return string.format("char(%d)",string.byte(I))end;return I else return self.tokens[I]end end;function e:lexerror(H,J,I)local function K(H,I)if I=="TK_NAME"or I=="TK_STRING"or I=="TK_NUMBER"then return H.buff else return self:token2str(H,I)end end;local l=self:chunkid(H.source,self.MAXSRC)local J=string.format("%s:%d: %s",l,H.linenumber,J)if I then J=string.format("%s near "..self.LUA_QS,J,K(H,I))end;error(J)end;function e:syntaxerror(H,J)self:lexerror(H,J,H.t.token)end;function e:currIsNewline(H)return H.current=="\n"or H.current=="\r"end;function e:inclinenumber(H)local L=H.current;self:nextc(H)if self:currIsNewline(H)and H.current~=L then self:nextc(H)end;H.linenumber=H.linenumber+1;if H.linenumber>=self.MAX_INT then self:syntaxerror(H,"chunk has too many lines")end end;function e:setinput(M,H,s,o)if not H then H={}end;if not H.lookahead then H.lookahead={}end;if not H.t then H.t={}end;H.decpoint="."H.L=M;H.lookahead.token="TK_EOS"H.z=s;H.fs=nil;H.linenumber=1;H.lastline=1;H.source=o;self:nextc(H)end;function e:check_next(H,N)if not string.find(N,H.current,1,1)then return false end;self:save_and_next(H)return true end;function e:next(H)H.lastline=H.linenumber;if H.lookahead.token~="TK_EOS"then H.t.seminfo=H.lookahead.seminfo;H.t.token=H.lookahead.token;H.lookahead.token="TK_EOS"else H.t.token=self:llex(H,H.t)end end;function e:lookahead(H)H.lookahead.token=self:llex(H,H.lookahead)end;function e:nextc(H)local O=c:zgetc(H.z)H.current=O;return O end;function e:save(H,O)local l=H.buff;H.buff=l..O end;function e:save_and_next(H)self:save(H,H.current)return self:nextc(H)end;function e:str2d(P)local Q=tonumber(P)if Q then return Q end;if string.lower(string.sub(P,1,2))=="0x"then Q=tonumber(P,16)if Q then return Q end end;return nil end;function e:buffreplace(H,R,S)local Q,l="",H.buff;for u=1,#l do local O=string.sub(l,u,u)if O==R then O=S end;Q=Q..O end;H.buff=Q end;function e:trydecpoint(H,T)local L=H.decpoint;self:buffreplace(H,L,H.decpoint)local U=self:str2d(H.buff)T.seminfo=U;if not U then self:buffreplace(H,H.decpoint,".")self:lexerror(H,"malformed number","TK_NUMBER")end end;function e:read_numeral(H,T)repeat self:save_and_next(H)until string.find(H.current,"%D")and H.current~="."if self:check_next(H,"Ee")then self:check_next(H,"+-")end;while string.find(H.current,"^%w$")or H.current=="_"do self:save_and_next(H)end;self:buffreplace(H,".",H.decpoint)local U=self:str2d(H.buff)T.seminfo=U;if not U then self:trydecpoint(H,T)end end;function e:skip_sep(H)local V=0;local P=H.current;self:save_and_next(H)while H.current=="="do self:save_and_next(H)V=V+1 end;return H.current==P and V or-V-1 end;function e:read_long_string(H,T,W)local X=0;self:save_and_next(H)if self:currIsNewline(H)then self:inclinenumber(H)end;while true do local O=H.current;if O=="EOZ"then self:lexerror(H,T and"unfinished long string"or"unfinished long comment","TK_EOS")elseif O=="["then if self.LUA_COMPAT_LSTR then if self:skip_sep(H)==W then self:save_and_next(H)X=X+1;if self.LUA_COMPAT_LSTR==1 then if W==0 then self:lexerror(H,"nesting of [[...]] is deprecated","[")end end end end elseif O=="]"then if self:skip_sep(H)==W then self:save_and_next(H)if self.LUA_COMPAT_LSTR and self.LUA_COMPAT_LSTR==2 then X=X-1;if W==0 and X>=0 then break end end;break end elseif self:currIsNewline(H)then self:save(H,"\n")self:inclinenumber(H)if not T then H.buff=""end else if T then self:save_and_next(H)else self:nextc(H)end end end;if T then local u=3+W;T.seminfo=string.sub(H.buff,u,-u)end end;function e:read_string(H,Y,T)self:save_and_next(H)while H.current~=Y do local O=H.current;if O=="EOZ"then self:lexerror(H,"unfinished string","TK_EOS")elseif self:currIsNewline(H)then self:lexerror(H,"unfinished string","TK_STRING")elseif O=="\\"then O=self:nextc(H)if self:currIsNewline(H)then self:save(H,"\n")self:inclinenumber(H)elseif O~="EOZ"then local Z=string.find("abfnrtv",O,1,1)if Z then self:save(H,string.sub("\a\b\f\n\r\t\v",Z,Z))self:nextc(H)elseif not string.find(O,"%d")then self:save_and_next(H)else O,Z=0,0;repeat O=10*O+H.current;self:nextc(H)Z=Z+1 until Z>=3 or not string.find(H.current,"%d")if O>255 then self:lexerror(H,"escape sequence too large","TK_STRING")end;self:save(H,string.char(O))end end else self:save_and_next(H)end end;self:save_and_next(H)T.seminfo=string.sub(H.buff,2,-2)end;function e:llex(H,T)H.buff=""while true do local O=H.current;if self:currIsNewline(H)then self:inclinenumber(H)elseif O=="-"then O=self:nextc(H)if O~="-"then return"-"end;local W=-1;if self:nextc(H)=='['then W=self:skip_sep(H)H.buff=""end;if W>=0 then self:read_long_string(H,nil,W)H.buff=""else while not self:currIsNewline(H)and H.current~="EOZ"do self:nextc(H)end end elseif O=="["then local W=self:skip_sep(H)if W>=0 then self:read_long_string(H,T,W)return"TK_STRING"elseif W==-1 then return"["else self:lexerror(H,"invalid long string delimiter","TK_STRING")end elseif O=="="then O=self:nextc(H)if O~="="then return"="else self:nextc(H)return"TK_EQ"end elseif O=="<"then O=self:nextc(H)if O~="="then return"<"else self:nextc(H)return"TK_LE"end elseif O==">"then O=self:nextc(H)if O~="="then return">"else self:nextc(H)return"TK_GE"end elseif O=="~"then O=self:nextc(H)if O~="="then return"~"else self:nextc(H)return"TK_NE"end elseif O=="\""or O=="'"then self:read_string(H,O,T)return"TK_STRING"elseif O=="."then O=self:save_and_next(H)if self:check_next(H,".")then if self:check_next(H,".")then return"TK_DOTS"else return"TK_CONCAT"end elseif not string.find(O,"%d")then return"."else self:read_numeral(H,T)return"TK_NUMBER"end elseif O=="EOZ"then return"TK_EOS"else if string.find(O,"%s")then self:nextc(H)elseif string.find(O,"%d")then self:read_numeral(H,T)return"TK_NUMBER"elseif string.find(O,"[_%a]")then repeat O=self:save_and_next(H)until O=="EOZ"or not string.find(O,"[_%w]")local _=H.buff;local A=self.enums[_]if A then return A end;T.seminfo=_;return"TK_NAME"else self:nextc(H)return O end end end end;f.OpMode={iABC=0,iABx=1,iAsBx=2}f.SIZE_C=9;f.SIZE_B=9;f.SIZE_Bx=f.SIZE_C+f.SIZE_B;f.SIZE_A=8;f.SIZE_OP=6;f.POS_OP=0;f.POS_A=f.POS_OP+f.SIZE_OP;f.POS_C=f.POS_A+f.SIZE_A;f.POS_B=f.POS_C+f.SIZE_C;f.POS_Bx=f.POS_C;f.MAXARG_Bx=math.ldexp(1,f.SIZE_Bx)-1;f.MAXARG_sBx=math.floor(f.MAXARG_Bx/2)f.MAXARG_A=math.ldexp(1,f.SIZE_A)-1;f.MAXARG_B=math.ldexp(1,f.SIZE_B)-1;f.MAXARG_C=math.ldexp(1,f.SIZE_C)-1;function f:GET_OPCODE(Z)return self.ROpCode[Z.OP]end;function f:SET_OPCODE(Z,a0)Z.OP=self.OpCode[a0]end;function f:GETARG_A(Z)return Z.A end;function f:SETARG_A(Z,a1)Z.A=a1 end;function f:GETARG_B(Z)return Z.B end;function f:SETARG_B(Z,m)Z.B=m end;function f:GETARG_C(Z)return Z.C end;function f:SETARG_C(Z,m)Z.C=m end;function f:GETARG_Bx(Z)return Z.Bx end;function f:SETARG_Bx(Z,m)Z.Bx=m end;function f:GETARG_sBx(Z)return Z.Bx-self.MAXARG_sBx end;function f:SETARG_sBx(Z,m)Z.Bx=m+self.MAXARG_sBx end;function f:CREATE_ABC(a0,a2,m,O)return{OP=self.OpCode[a0],A=a2,B=m,C=O}end;function f:CREATE_ABx(a0,a2,a3)return{OP=self.OpCode[a0],A=a2,Bx=a3}end;function f:CREATE_Inst(O)local a0=O%64;O=(O-a0)/64;local a2=O%256;O=(O-a2)/256;return self:CREATE_ABx(a0,a2,O)end;function f:Instruction(Z)if Z.Bx then Z.C=Z.Bx%512;Z.B=(Z.Bx-Z.C)/512 end;local a4=Z.A*64+Z.OP;local a5=a4%256;a4=Z.C*64+(a4-a5)/256;local a6=a4%256;a4=Z.B*128+(a4-a6)/256;local a7=a4%256;local a8=(a4-a7)/256;return string.char(a5,a6,a7,a8)end;function f:DecodeInst(x)local a9=string.byte;local Z={}local a4=a9(x,1)local aa=a4%64;Z.OP=aa;a4=a9(x,2)*4+(a4-aa)/64;local a2=a4%256;Z.A=a2;a4=a9(x,3)*4+(a4-a2)/256;local O=a4%512;Z.C=O;Z.B=a9(x,4)*2+(a4-O)/512;local ab=self.OpMode[tonumber(string.sub(self.opmodes[aa+1],7,7))]if ab~="iABC"then Z.Bx=Z.B*512+Z.C end;return Z end;f.BITRK=math.ldexp(1,f.SIZE_B-1)function f:ISK(x)return x>=self.BITRK end;function f:INDEXK(ac)return x-self.BITRK end;f.MAXINDEXRK=f.BITRK-1;function f:RKASK(x)return x+self.BITRK end;f.NO_REG=f.MAXARG_A;f.opnames={}f.OpCode={}f.ROpCode={}local Z=0;for y in string.gmatch("MOVE LOADK LOADBOOL LOADNIL GETUPVAL\nGETGLOBAL GETTABLE SETGLOBAL SETUPVAL SETTABLE\nNEWTABLE SELF ADD SUB MUL\nDIV MOD POW UNM NOT\nLEN CONCAT JMP EQ LT\nLE TEST TESTSET CALL TAILCALL\nRETURN FORLOOP FORPREP TFORLOOP SETLIST\nCLOSE CLOSURE VARARG","%S+")do local t="OP_"..y;f.opnames[Z]=y;f.OpCode[t]=Z;f.ROpCode[Z]=t;Z=Z+1 end;f.NUM_OPCODES=Z;f.OpArgMask={OpArgN=0,OpArgU=1,OpArgR=2,OpArgK=3}function f:getOpMode(ad)return self.opmodes[self.OpCode[ad]]%4 end;function f:getBMode(ad)return math.floor(self.opmodes[self.OpCode[ad]]/16)%4 end;function f:getCMode(ad)return math.floor(self.opmodes[self.OpCode[ad]]/4)%4 end;function f:testAMode(ad)return math.floor(self.opmodes[self.OpCode[ad]]/64)%2 end;function f:testTMode(ad)return math.floor(self.opmodes[self.OpCode[ad]]/128)end;f.LFIELDS_PER_FLUSH=50;local function ab(ae,a2,m,O,ad)local f=f;return ae*128+a2*64+f.OpArgMask[m]*16+f.OpArgMask[O]*4+f.OpMode[ad]end;f.opmodes={ab(0,1,"OpArgK","OpArgN","iABx"),ab(0,1,"OpArgU","OpArgU","iABC"),ab(0,1,"OpArgR","OpArgN","iABC"),ab(0,1,"OpArgU","OpArgN","iABC"),ab(0,1,"OpArgK","OpArgN","iABx"),ab(0,1,"OpArgR","OpArgK","iABC"),ab(0,0,"OpArgK","OpArgN","iABx"),ab(0,0,"OpArgU","OpArgN","iABC"),ab(0,0,"OpArgK","OpArgK","iABC"),ab(0,1,"OpArgU","OpArgU","iABC"),ab(0,1,"OpArgR","OpArgK","iABC"),ab(0,1,"OpArgK","OpArgK","iABC"),ab(0,1,"OpArgK","OpArgK","iABC"),ab(0,1,"OpArgK","OpArgK","iABC"),ab(0,1,"OpArgK","OpArgK","iABC"),ab(0,1,"OpArgK","OpArgK","iABC"),ab(0,1,"OpArgK","OpArgK","iABC"),ab(0,1,"OpArgR","OpArgN","iABC"),ab(0,1,"OpArgR","OpArgN","iABC"),ab(0,1,"OpArgR","OpArgN","iABC"),ab(0,1,"OpArgR","OpArgR","iABC"),ab(0,0,"OpArgR","OpArgN","iAsBx"),ab(1,0,"OpArgK","OpArgK","iABC"),ab(1,0,"OpArgK","OpArgK","iABC"),ab(1,0,"OpArgK","OpArgK","iABC"),ab(1,1,"OpArgR","OpArgU","iABC"),ab(1,1,"OpArgR","OpArgU","iABC"),ab(0,1,"OpArgU","OpArgU","iABC"),ab(0,1,"OpArgU","OpArgU","iABC"),ab(0,0,"OpArgU","OpArgN","iABC"),ab(0,1,"OpArgR","OpArgN","iAsBx"),ab(0,1,"OpArgR","OpArgN","iAsBx"),ab(1,0,"OpArgN","OpArgU","iABC"),ab(0,0,"OpArgU","OpArgU","iABC"),ab(0,0,"OpArgN","OpArgN","iABC"),ab(0,1,"OpArgU","OpArgN","iABx"),ab(0,1,"OpArgU","OpArgN","iABC")}f.opmodes[0]=ab(0,1,"OpArgR","OpArgN","iABC")g.LUA_SIGNATURE="\27Lua"g.LUA_TNUMBER=3;g.LUA_TSTRING=4;g.LUA_TNIL=0;g.LUA_TBOOLEAN=1;g.LUA_TNONE=-1;g.LUAC_VERSION=0x51;g.LUAC_FORMAT=0;g.LUAC_HEADERSIZE=12;function g:make_setS()local l={}l.data=""local af=function(P,l)if not P then return 0 end;l.data=l.data..P;return 0 end;return af,l end;function g:make_setF(ag)local l={}l.h=io.open(ag,"wb")if not l.h then return nil end;local af=function(P,l)if not l.h then return 0 end;if not P then if l.h:close()then return 0 end else if l.h:write(P)then return 0 end end;return 1 end;return af,l end;function g:ttype(a0)local ah=type(a0.value)if ah=="number"then return self.LUA_TNUMBER elseif ah=="string"then return self.LUA_TSTRING elseif ah=="nil"then return self.LUA_TNIL elseif ah=="boolean"then return self.LUA_TBOOLEAN else return self.LUA_TNONE end end;function g:from_double(x)local function ai(y)local O=y%256;return(y-O)/256,string.char(O)end;local aj=0;if x<0 then aj=1;x=-x end;local ak,al=math.frexp(x)if x==0 then ak,al=0,0 elseif x==1/0 then ak,al=0,2047 else ak=(ak*2-1)*math.ldexp(0.5,53)al=al+1022 end;local y,a9=""x=math.floor(ak)for Z=1,6 do x,a9=ai(x)y=y..a9 end;x,a9=ai(al*16+x)y=y..a9;x,a9=ai(aj*128+x)y=y..a9;return y end;function g:from_int(x)local y=""x=math.floor(x)if x<0 then x=4294967296+x end;for Z=1,4 do local O=x%256;y=y..string.char(O)x=math.floor(x/256)end;return y end;function g:DumpBlock(m,am)if am.status==0 then am.status=am.write(m,am.data)end end;function g:DumpChar(an,am)self:DumpBlock(string.char(an),am)end;function g:DumpInt(x,am)self:DumpBlock(self:from_int(x),am)end;function g:DumpSizeT(x,am)self:DumpBlock(self:from_int(x),am)if i==8 then self:DumpBlock(self:from_int(0),am)end end;function g:DumpNumber(x,am)self:DumpBlock(self:from_double(x),am)end;function g:DumpString(P,am)if P==nil then self:DumpSizeT(0,am)else P=P.."\0"self:DumpSizeT(#P,am)self:DumpBlock(P,am)end end;function g:DumpCode(ao,am)local t=ao.sizecode;self:DumpInt(t,am)for Z=0,t-1 do self:DumpBlock(f:Instruction(ao.code[Z]),am)end end;function g:DumpConstants(ao,am)local t=ao.sizek;self:DumpInt(t,am)for Z=0,t-1 do local a0=ao.k[Z]local ah=self:ttype(a0)self:DumpChar(ah,am)if ah==self.LUA_TNIL then elseif ah==self.LUA_TBOOLEAN then self:DumpChar(a0.value and 1 or 0,am)elseif ah==self.LUA_TNUMBER then self:DumpNumber(a0.value,am)elseif ah==self.LUA_TSTRING then self:DumpString(a0.value,am)else end end;t=ao.sizep;self:DumpInt(t,am)for Z=0,t-1 do self:DumpFunction(ao.p[Z],ao.source,am)end end;function g:DumpDebug(ao,am)local t;t=am.strip and 0 or ao.sizelineinfo;self:DumpInt(t,am)for Z=0,t-1 do self:DumpInt(ao.lineinfo[Z],am)end;t=am.strip and 0 or ao.sizelocvars;self:DumpInt(t,am)for Z=0,t-1 do self:DumpString(ao.locvars[Z].varname,am)self:DumpInt(ao.locvars[Z].startpc,am)self:DumpInt(ao.locvars[Z].endpc,am)end;t=am.strip and 0 or ao.sizeupvalues;self:DumpInt(t,am)for Z=0,t-1 do self:DumpString(ao.upvalues[Z],am)end end;function g:DumpFunction(ao,u,am)local o=ao.source;if o==u or am.strip then o=nil end;self:DumpString(o,am)self:DumpInt(ao.lineDefined,am)self:DumpInt(ao.lastlinedefined,am)self:DumpChar(ao.nups,am)self:DumpChar(ao.numparams,am)self:DumpChar(ao.is_vararg,am)self:DumpChar(ao.maxstacksize,am)self:DumpCode(ao,am)self:DumpConstants(ao,am)self:DumpDebug(ao,am)end;function g:DumpHeader(am)local ap=self:header()assert(#ap==self.LUAC_HEADERSIZE)self:DumpBlock(ap,am)end;function g:header()local x=1;return self.LUA_SIGNATURE..string.char(self.LUAC_VERSION,self.LUAC_FORMAT,x,4,i,4,8,0)end;function g:dump(M,ao,aq,n,ar)local am={}am.L=M;am.write=aq;am.data=n;am.strip=ar;am.status=0;self:DumpHeader(am)self:DumpFunction(ao,nil,am)am.write(nil,am.data)return am.status end;h.MAXSTACK=250;function h:ttisnumber(a0)if a0 then return type(a0.value)=="number"else return false end end;function h:nvalue(a0)return a0.value end;function h:setnilvalue(a0)a0.value=nil end;function h:setsvalue(a0,x)a0.value=x end;h.setnvalue=h.setsvalue;h.sethvalue=h.setsvalue;h.setbvalue=h.setsvalue;function h:numadd(a2,m)return a2+m end;function h:numsub(a2,m)return a2-m end;function h:nummul(a2,m)return a2*m end;function h:numdiv(a2,m)return a2/m end;function h:nummod(a2,m)return a2%m end;function h:numpow(a2,m)return a2^m end;function h:numunm(a2)return-a2 end;function h:numisnan(a2)return not a2==a2 end;h.NO_JUMP=-1;h.BinOpr={OPR_ADD=0,OPR_SUB=1,OPR_MUL=2,OPR_DIV=3,OPR_MOD=4,OPR_POW=5,OPR_CONCAT=6,OPR_NE=7,OPR_EQ=8,OPR_LT=9,OPR_LE=10,OPR_GT=11,OPR_GE=12,OPR_AND=13,OPR_OR=14,OPR_NOBINOPR=15}h.UnOpr={OPR_MINUS=0,OPR_NOT=1,OPR_LEN=2,OPR_NOUNOPR=3}function h:getcode(as,at)return as.f.code[at.info]end;function h:codeAsBx(as,a0,au,av)return self:codeABx(as,a0,au,av+f.MAXARG_sBx)end;function h:setmultret(as,at)self:setreturns(as,at,d.LUA_MULTRET)end;function h:hasjumps(at)return at.t~=at.f end;function h:isnumeral(at)return at.k=="VKNUM"and at.t==self.NO_JUMP and at.f==self.NO_JUMP end;function h:_nil(as,R,t)if as.pc>as.lasttarget then if as.pc==0 then if R>=as.nactvar then return end else local aw=as.f.code[as.pc-1]if f:GET_OPCODE(aw)=="OP_LOADNIL"then local ax=f:GETARG_A(aw)local ay=f:GETARG_B(aw)if ax<=R and R<=ay+1 then if R+t-1>ay then f:SETARG_B(aw,R+t-1)end;return end end end end;self:codeABC(as,"OP_LOADNIL",R,R+t-1,0)end;function h:jump(as)local az=as.jpc;as.jpc=self.NO_JUMP;local aA=self:codeAsBx(as,"OP_JMP",0,self.NO_JUMP)aA=self:concat(as,aA,az)return aA end;function h:ret(as,E,aB)self:codeABC(as,"OP_RETURN",E,aB+1,0)end;function h:condjump(as,aa,au,aC,aD)self:codeABC(as,aa,au,aC,aD)return self:jump(as)end;function h:fixjump(as,aE,aF)local aG=as.f.code[aE]local aH=aF-(aE+1)j(aF~=self.NO_JUMP)if math.abs(aH)>f.MAXARG_sBx then e:syntaxerror(as.ls,"control structure too long")end;f:SETARG_sBx(aG,aH)end;function h:getlabel(as)as.lasttarget=as.pc;return as.pc end;function h:getjump(as,aE)local aH=f:GETARG_sBx(as.f.code[aE])if aH==self.NO_JUMP then return self.NO_JUMP else return aE+1+aH end end;function h:getjumpcontrol(as,aE)local aI=as.f.code[aE]local aJ=as.f.code[aE-1]if aE>=1 and f:testTMode(f:GET_OPCODE(aJ))~=0 then return aJ else return aI end end;function h:need_value(as,aK)while aK~=self.NO_JUMP do local Z=self:getjumpcontrol(as,aK)if f:GET_OPCODE(Z)~="OP_TESTSET"then return true end;aK=self:getjump(as,aK)end;return false end;function h:patchtestreg(as,aL,aM)local Z=self:getjumpcontrol(as,aL)if f:GET_OPCODE(Z)~="OP_TESTSET"then return false end;if aM~=f.NO_REG and aM~=f:GETARG_B(Z)then f:SETARG_A(Z,aM)else f:SET_OPCODE(Z,"OP_TEST")local m=f:GETARG_B(Z)f:SETARG_A(Z,m)f:SETARG_B(Z,0)end;return true end;function h:removevalues(as,aK)while aK~=self.NO_JUMP do self:patchtestreg(as,aK,f.NO_REG)aK=self:getjump(as,aK)end end;function h:patchlistaux(as,aK,aN,aM,aO)while aK~=self.NO_JUMP do local aP=self:getjump(as,aK)if self:patchtestreg(as,aK,aM)then self:fixjump(as,aK,aN)else self:fixjump(as,aK,aO)end;aK=aP end end;function h:dischargejpc(as)self:patchlistaux(as,as.jpc,as.pc,f.NO_REG,as.pc)as.jpc=self.NO_JUMP end;function h:patchlist(as,aK,aQ)if aQ==as.pc then self:patchtohere(as,aK)else j(aQ<as.pc)self:patchlistaux(as,aK,aQ,f.NO_REG,aQ)end end;function h:patchtohere(as,aK)self:getlabel(as)as.jpc=self:concat(as,as.jpc,aK)end;function h:concat(as,aR,aS)if aS==self.NO_JUMP then return aR elseif aR==self.NO_JUMP then return aS else local aK=aR;local aP=self:getjump(as,aK)while aP~=self.NO_JUMP do aK=aP;aP=self:getjump(as,aK)end;self:fixjump(as,aK,aS)end;return aR end;function h:checkstack(as,t)local aT=as.freereg+t;if aT>as.f.maxstacksize then if aT>=self.MAXSTACK then e:syntaxerror(as.ls,"function or expression too complex")end;as.f.maxstacksize=aT end end;function h:reserveregs(as,t)self:checkstack(as,t)as.freereg=as.freereg+t end;function h:freereg(as,aM)if not f:ISK(aM)and aM>=as.nactvar then as.freereg=as.freereg-1;j(aM==as.freereg)end end;function h:freeexp(as,at)if at.k=="VNONRELOC"then self:freereg(as,at.info)end end;function h:addk(as,aU,y)local M=as.L;local aV=as.h[aU.value]local ao=as.f;if self:ttisnumber(aV)then return self:nvalue(aV)else aV={}self:setnvalue(aV,as.nk)as.h[aU.value]=aV;d:growvector(M,ao.k,as.nk,ao.sizek,nil,f.MAXARG_Bx,"constant table overflow")ao.k[as.nk]=y;local aW=as.nk;as.nk=as.nk+1;return aW end end;function h:stringK(as,P)local a0={}self:setsvalue(a0,P)return self:addk(as,a0,a0)end;function h:numberK(as,ac)local a0={}self:setnvalue(a0,ac)return self:addk(as,a0,a0)end;function h:boolK(as,m)local a0={}self:setbvalue(a0,m)return self:addk(as,a0,a0)end;function h:nilK(as)local aU,y={},{}self:setnilvalue(y)self:sethvalue(aU,as.h)return self:addk(as,aU,y)end;function h:setreturns(as,at,aX)if at.k=="VCALL"then f:SETARG_C(self:getcode(as,at),aX+1)elseif at.k=="VVARARG"then f:SETARG_B(self:getcode(as,at),aX+1)f:SETARG_A(self:getcode(as,at),as.freereg)h:reserveregs(as,1)end end;function h:setoneret(as,at)if at.k=="VCALL"then at.k="VNONRELOC"at.info=f:GETARG_A(self:getcode(as,at))elseif at.k=="VVARARG"then f:SETARG_B(self:getcode(as,at),2)at.k="VRELOCABLE"end end;function h:dischargevars(as,at)local aU=at.k;if aU=="VLOCAL"then at.k="VNONRELOC"elseif aU=="VUPVAL"then at.info=self:codeABC(as,"OP_GETUPVAL",0,at.info,0)at.k="VRELOCABLE"elseif aU=="VGLOBAL"then at.info=self:codeABx(as,"OP_GETGLOBAL",0,at.info)at.k="VRELOCABLE"elseif aU=="VINDEXED"then self:freereg(as,at.aux)self:freereg(as,at.info)at.info=self:codeABC(as,"OP_GETTABLE",0,at.info,at.aux)at.k="VRELOCABLE"elseif aU=="VVARARG"or aU=="VCALL"then self:setoneret(as,at)else end end;function h:code_label(as,au,m,aY)self:getlabel(as)return self:codeABC(as,"OP_LOADBOOL",au,m,aY)end;function h:discharge2reg(as,at,aM)self:dischargevars(as,at)local aU=at.k;if aU=="VNIL"then self:_nil(as,aM,1)elseif aU=="VFALSE"or aU=="VTRUE"then self:codeABC(as,"OP_LOADBOOL",aM,at.k=="VTRUE"and 1 or 0,0)elseif aU=="VK"then self:codeABx(as,"OP_LOADK",aM,at.info)elseif aU=="VKNUM"then self:codeABx(as,"OP_LOADK",aM,self:numberK(as,at.nval))elseif aU=="VRELOCABLE"then local aE=self:getcode(as,at)f:SETARG_A(aE,aM)elseif aU=="VNONRELOC"then if aM~=at.info then self:codeABC(as,"OP_MOVE",aM,at.info,0)end else j(at.k=="VVOID"or at.k=="VJMP")return end;at.info=aM;at.k="VNONRELOC"end;function h:discharge2anyreg(as,at)if at.k~="VNONRELOC"then self:reserveregs(as,1)self:discharge2reg(as,at,as.freereg-1)end end;function h:exp2reg(as,at,aM)self:discharge2reg(as,at,aM)if at.k=="VJMP"then at.t=self:concat(as,at.t,at.info)end;if self:hasjumps(at)then local aZ;local a_=self.NO_JUMP;local b0=self.NO_JUMP;if self:need_value(as,at.t)or self:need_value(as,at.f)then local b1=at.k=="VJMP"and self.NO_JUMP or self:jump(as)a_=self:code_label(as,aM,0,1)b0=self:code_label(as,aM,1,0)self:patchtohere(as,b1)end;aZ=self:getlabel(as)self:patchlistaux(as,at.f,aZ,aM,a_)self:patchlistaux(as,at.t,aZ,aM,b0)end;at.f,at.t=self.NO_JUMP,self.NO_JUMP;at.info=aM;at.k="VNONRELOC"end;function h:exp2nextreg(as,at)self:dischargevars(as,at)self:freeexp(as,at)self:reserveregs(as,1)self:exp2reg(as,at,as.freereg-1)end;function h:exp2anyreg(as,at)self:dischargevars(as,at)if at.k=="VNONRELOC"then if not self:hasjumps(at)then return at.info end;if at.info>=as.nactvar then self:exp2reg(as,at,at.info)return at.info end end;self:exp2nextreg(as,at)return at.info end;function h:exp2val(as,at)if self:hasjumps(at)then self:exp2anyreg(as,at)else self:dischargevars(as,at)end end;function h:exp2RK(as,at)self:exp2val(as,at)local aU=at.k;if aU=="VKNUM"or aU=="VTRUE"or aU=="VFALSE"or aU=="VNIL"then if as.nk<=f.MAXINDEXRK then if at.k=="VNIL"then at.info=self:nilK(as)else at.info=at.k=="VKNUM"and self:numberK(as,at.nval)or self:boolK(as,at.k=="VTRUE")end;at.k="VK"return f:RKASK(at.info)end elseif aU=="VK"then if at.info<=f.MAXINDEXRK then return f:RKASK(at.info)end else end;return self:exp2anyreg(as,at)end;function h:storevar(as,b2,b3)local aU=b2.k;if aU=="VLOCAL"then self:freeexp(as,b3)self:exp2reg(as,b3,b2.info)return elseif aU=="VUPVAL"then local at=self:exp2anyreg(as,b3)self:codeABC(as,"OP_SETUPVAL",at,b2.info,0)elseif aU=="VGLOBAL"then local at=self:exp2anyreg(as,b3)self:codeABx(as,"OP_SETGLOBAL",at,b2.info)elseif aU=="VINDEXED"then local at=self:exp2RK(as,b3)self:codeABC(as,"OP_SETTABLE",b2.info,b2.aux,at)else j(0)end;self:freeexp(as,b3)end;function h:_self(as,at,b4)self:exp2anyreg(as,at)self:freeexp(as,at)local b5=as.freereg;self:reserveregs(as,2)self:codeABC(as,"OP_SELF",b5,at.info,self:exp2RK(as,b4))self:freeexp(as,b4)at.info=b5;at.k="VNONRELOC"end;function h:invertjump(as,at)local aE=self:getjumpcontrol(as,at.info)j(f:testTMode(f:GET_OPCODE(aE))~=0 and f:GET_OPCODE(aE)~="OP_TESTSET"and f:GET_OPCODE(aE)~="OP_TEST")f:SETARG_A(aE,f:GETARG_A(aE)==0 and 1 or 0)end;function h:jumponcond(as,at,b6)if at.k=="VRELOCABLE"then local b7=self:getcode(as,at)if f:GET_OPCODE(b7)=="OP_NOT"then as.pc=as.pc-1;return self:condjump(as,"OP_TEST",f:GETARG_B(b7),0,b6 and 0 or 1)end end;self:discharge2anyreg(as,at)self:freeexp(as,at)return self:condjump(as,"OP_TESTSET",f.NO_REG,at.info,b6 and 1 or 0)end;function h:goiftrue(as,at)local aE;self:dischargevars(as,at)local aU=at.k;if aU=="VK"or aU=="VKNUM"or aU=="VTRUE"then aE=self.NO_JUMP elseif aU=="VFALSE"then aE=self:jump(as)elseif aU=="VJMP"then self:invertjump(as,at)aE=at.info else aE=self:jumponcond(as,at,false)end;at.f=self:concat(as,at.f,aE)self:patchtohere(as,at.t)at.t=self.NO_JUMP end;function h:goiffalse(as,at)local aE;self:dischargevars(as,at)local aU=at.k;if aU=="VNIL"or aU=="VFALSE"then aE=self.NO_JUMP elseif aU=="VTRUE"then aE=self:jump(as)elseif aU=="VJMP"then aE=at.info else aE=self:jumponcond(as,at,true)end;at.t=self:concat(as,at.t,aE)self:patchtohere(as,at.f)at.f=self.NO_JUMP end;function h:codenot(as,at)self:dischargevars(as,at)local aU=at.k;if aU=="VNIL"or aU=="VFALSE"then at.k="VTRUE"elseif aU=="VK"or aU=="VKNUM"or aU=="VTRUE"then at.k="VFALSE"elseif aU=="VJMP"then self:invertjump(as,at)elseif aU=="VRELOCABLE"or aU=="VNONRELOC"then self:discharge2anyreg(as,at)self:freeexp(as,at)at.info=self:codeABC(as,"OP_NOT",0,at.info,0)at.k="VRELOCABLE"else j(0)end;at.f,at.t=at.t,at.f;self:removevalues(as,at.f)self:removevalues(as,at.t)end;function h:indexed(as,ae,aU)ae.aux=self:exp2RK(as,aU)ae.k="VINDEXED"end;function h:constfolding(aa,b8,b9)local ac;if not self:isnumeral(b8)or not self:isnumeral(b9)then return false end;local ba=b8.nval;local bb=b9.nval;if aa=="OP_ADD"then ac=self:numadd(ba,bb)elseif aa=="OP_SUB"then ac=self:numsub(ba,bb)elseif aa=="OP_MUL"then ac=self:nummul(ba,bb)elseif aa=="OP_DIV"then if bb==0 then return false end;ac=self:numdiv(ba,bb)elseif aa=="OP_MOD"then if bb==0 then return false end;ac=self:nummod(ba,bb)elseif aa=="OP_POW"then ac=self:numpow(ba,bb)elseif aa=="OP_UNM"then ac=self:numunm(ba)elseif aa=="OP_LEN"then return false else j(0)ac=0 end;if self:numisnan(ac)then return false end;b8.nval=ac;return true end;function h:codearith(as,aa,b8,b9)if self:constfolding(aa,b8,b9)then return else local bc=aa~="OP_UNM"and aa~="OP_LEN"and self:exp2RK(as,b9)or 0;local bd=self:exp2RK(as,b8)if bd>bc then self:freeexp(as,b8)self:freeexp(as,b9)else self:freeexp(as,b9)self:freeexp(as,b8)end;b8.info=self:codeABC(as,aa,0,bd,bc)b8.k="VRELOCABLE"end end;function h:codecomp(as,aa,b6,b8,b9)local bd=self:exp2RK(as,b8)local bc=self:exp2RK(as,b9)self:freeexp(as,b9)self:freeexp(as,b8)if b6==0 and aa~="OP_EQ"then bd,bc=bc,bd;b6=1 end;b8.info=self:condjump(as,aa,b6,bd,bc)b8.k="VJMP"end;function h:prefix(as,aa,at)local b9={}b9.t,b9.f=self.NO_JUMP,self.NO_JUMP;b9.k="VKNUM"b9.nval=0;if aa=="OPR_MINUS"then if not self:isnumeral(at)then self:exp2anyreg(as,at)end;self:codearith(as,"OP_UNM",at,b9)elseif aa=="OPR_NOT"then self:codenot(as,at)elseif aa=="OPR_LEN"then self:exp2anyreg(as,at)self:codearith(as,"OP_LEN",at,b9)else j(0)end end;function h:infix(as,aa,y)if aa=="OPR_AND"then self:goiftrue(as,y)elseif aa=="OPR_OR"then self:goiffalse(as,y)elseif aa=="OPR_CONCAT"then self:exp2nextreg(as,y)elseif aa=="OPR_ADD"or aa=="OPR_SUB"or aa=="OPR_MUL"or aa=="OPR_DIV"or aa=="OPR_MOD"or aa=="OPR_POW"then if not self:isnumeral(y)then self:exp2RK(as,y)end else self:exp2RK(as,y)end end;h.arith_op={OPR_ADD="OP_ADD",OPR_SUB="OP_SUB",OPR_MUL="OP_MUL",OPR_DIV="OP_DIV",OPR_MOD="OP_MOD",OPR_POW="OP_POW"}h.comp_op={OPR_EQ="OP_EQ",OPR_NE="OP_EQ",OPR_LT="OP_LT",OPR_LE="OP_LE",OPR_GT="OP_LT",OPR_GE="OP_LE"}h.comp_cond={OPR_EQ=1,OPR_NE=0,OPR_LT=1,OPR_LE=1,OPR_GT=0,OPR_GE=0}function h:posfix(as,aa,b8,b9)local function be(b8,b9)b8.k=b9.k;b8.info=b9.info;b8.aux=b9.aux;b8.nval=b9.nval;b8.t=b9.t;b8.f=b9.f end;if aa=="OPR_AND"then j(b8.t==self.NO_JUMP)self:dischargevars(as,b9)b9.f=self:concat(as,b9.f,b8.f)be(b8,b9)elseif aa=="OPR_OR"then j(b8.f==self.NO_JUMP)self:dischargevars(as,b9)b9.t=self:concat(as,b9.t,b8.t)be(b8,b9)elseif aa=="OPR_CONCAT"then self:exp2val(as,b9)if b9.k=="VRELOCABLE"and f:GET_OPCODE(self:getcode(as,b9))=="OP_CONCAT"then j(b8.info==f:GETARG_B(self:getcode(as,b9))-1)self:freeexp(as,b8)f:SETARG_B(self:getcode(as,b9),b8.info)b8.k="VRELOCABLE"b8.info=b9.info else self:exp2nextreg(as,b9)self:codearith(as,"OP_CONCAT",b8,b9)end else local bf=self.arith_op[aa]if bf then self:codearith(as,bf,b8,b9)else local bg=self.comp_op[aa]if bg then self:codecomp(as,bg,self.comp_cond[aa],b8,b9)else j(0)end end end end;function h:fixline(as,bh)as.f.lineinfo[as.pc-1]=bh end;function h:code(as,Z,bh)local ao=as.f;self:dischargejpc(as)d:growvector(as.L,ao.code,as.pc,ao.sizecode,nil,d.MAX_INT,"code size overflow")ao.code[as.pc]=Z;d:growvector(as.L,ao.lineinfo,as.pc,ao.sizelineinfo,nil,d.MAX_INT,"code size overflow")ao.lineinfo[as.pc]=bh;local aE=as.pc;as.pc=as.pc+1;return aE end;function h:codeABC(as,a0,a2,m,O)j(f:getOpMode(a0)==f.OpMode.iABC)j(f:getBMode(a0)~=f.OpArgMask.OpArgN or m==0)j(f:getCMode(a0)~=f.OpArgMask.OpArgN or O==0)return self:code(as,f:CREATE_ABC(a0,a2,m,O),as.ls.lastline)end;function h:codeABx(as,a0,a2,a3)j(f:getOpMode(a0)==f.OpMode.iABx or f:getOpMode(a0)==f.OpMode.iAsBx)j(f:getCMode(a0)==f.OpArgMask.OpArgN)return self:code(as,f:CREATE_ABx(a0,a2,a3),as.ls.lastline)end;function h:setlist(as,bi,bj,bk)local O=math.floor((bj-1)/f.LFIELDS_PER_FLUSH)+1;local m=bk==d.LUA_MULTRET and 0 or bk;j(bk~=0)if O<=f.MAXARG_C then self:codeABC(as,"OP_SETLIST",bi,m,O)else self:codeABC(as,"OP_SETLIST",bi,m,0)self:code(as,f:CREATE_Inst(O),as.ls.lastline)end;as.freereg=bi+1 end;d.LUA_QS=e.LUA_QS or"'%s'"d.SHRT_MAX=32767;d.LUAI_MAXVARS=200;d.LUAI_MAXUPVALUES=60;d.MAX_INT=e.MAX_INT or 2147483645;d.LUAI_MAXCCALLS=200;d.VARARG_HASARG=1;d.HASARG_MASK=2;d.VARARG_ISVARARG=2;d.VARARG_NEEDSARG=4;d.LUA_MULTRET=-1;function d:LUA_QL(x)return"'"..x.."'"end;function d:growvector(M,y,bj,bl,ae,bm,at)if bj>=bm then error(at)end end;function d:newproto(M)local ao={}ao.k={}ao.sizek=0;ao.p={}ao.sizep=0;ao.code={}ao.sizecode=0;ao.sizelineinfo=0;ao.sizeupvalues=0;ao.nups=0;ao.upvalues={}ao.numparams=0;ao.is_vararg=0;ao.maxstacksize=0;ao.lineinfo={}ao.sizelocvars=0;ao.locvars={}ao.lineDefined=0;ao.lastlinedefined=0;ao.source=nil;return ao end;function d:int2fb(x)local at=0;while x>=16 do x=math.floor((x+1)/2)at=at+1 end;if x<8 then return x else return(at+1)*8+x-8 end end;function d:hasmultret(aU)return aU=="VCALL"or aU=="VVARARG"end;function d:getlocvar(as,Z)return as.f.locvars[as.actvar[Z]]end;function d:checklimit(as,y,F,ad)if y>F then self:errorlimit(as,F,ad)end end;function d:anchor_token(H)if H.t.token=="TK_NAME"or H.t.token=="TK_STRING"then end end;function d:error_expected(H,I)e:syntaxerror(H,string.format(self.LUA_QS.." expected",e:token2str(H,I)))end;function d:errorlimit(as,bm,bn)local J=as.f.linedefined==0 and string.format("main function has more than %d %s",bm,bn)or string.format("function at line %d has more than %d %s",as.f.linedefined,bm,bn)e:lexerror(as.ls,J,0)end;function d:testnext(H,O)if H.t.token==O then e:next(H)return true else return false end end;function d:check(H,O)if H.t.token~=O then self:error_expected(H,O)end end;function d:checknext(H,O)self:check(H,O)e:next(H)end;function d:check_condition(H,O,J)if not O then e:syntaxerror(H,J)end end;function d:check_match(H,bn,bo,bp)if not self:testnext(H,bn)then if bp==H.linenumber then self:error_expected(H,bn)else e:syntaxerror(H,string.format(self.LUA_QS.." expected (to close "..self.LUA_QS.." at line %d)",e:token2str(H,bn),e:token2str(H,bo),bp))end end end;function d:str_checkname(H)self:check(H,"TK_NAME")local _=H.t.seminfo;e:next(H)return _ end;function d:init_exp(at,aU,Z)at.f,at.t=h.NO_JUMP,h.NO_JUMP;at.k=aU;at.info=Z end;function d:codestring(H,at,P)self:init_exp(at,"VK",h:stringK(H.fs,P))end;function d:checkname(H,at)self:codestring(H,at,self:str_checkname(H))end;function d:registerlocalvar(H,bq)local as=H.fs;local ao=as.f;self:growvector(H.L,ao.locvars,as.nlocvars,ao.sizelocvars,nil,self.SHRT_MAX,"too many local variables")ao.locvars[as.nlocvars]={}ao.locvars[as.nlocvars].varname=bq;local br=as.nlocvars;as.nlocvars=as.nlocvars+1;return br end;function d:new_localvarliteral(H,y,t)self:new_localvar(H,y,t)end;function d:new_localvar(H,name,t)local as=H.fs;self:checklimit(as,as.nactvar+t+1,self.LUAI_MAXVARS,"local variables")as.actvar[as.nactvar+t]=self:registerlocalvar(H,name)end;function d:adjustlocalvars(H,bs)local as=H.fs;as.nactvar=as.nactvar+bs;for Z=bs,1,-1 do self:getlocvar(as,as.nactvar-Z).startpc=as.pc end end;function d:removevars(H,bt)local as=H.fs;while as.nactvar>bt do as.nactvar=as.nactvar-1;self:getlocvar(as,as.nactvar).endpc=as.pc end end;function d:indexupvalue(as,name,y)local ao=as.f;for Z=0,ao.nups-1 do if as.upvalues[Z].k==y.k and as.upvalues[Z].info==y.info then j(ao.upvalues[Z]==name)return Z end end;self:checklimit(as,ao.nups+1,self.LUAI_MAXUPVALUES,"upvalues")self:growvector(as.L,ao.upvalues,ao.nups,ao.sizeupvalues,nil,self.MAX_INT,"")ao.upvalues[ao.nups]=name;j(y.k=="VLOCAL"or y.k=="VUPVAL")as.upvalues[ao.nups]={k=y.k,info=y.info}local bu=ao.nups;ao.nups=ao.nups+1;return bu end;function d:searchvar(as,t)for Z=as.nactvar-1,0,-1 do if t==self:getlocvar(as,Z).varname then return Z end end;return-1 end;function d:markupval(as,bv)local bw=as.bl;while bw and bw.nactvar>bv do bw=bw.previous end;if bw then bw.upval=true end end;function d:singlevaraux(as,t,b2,bi)if as==nil then self:init_exp(b2,"VGLOBAL",f.NO_REG)return"VGLOBAL"else local y=self:searchvar(as,t)if y>=0 then self:init_exp(b2,"VLOCAL",y)if bi==0 then self:markupval(as,y)end;return"VLOCAL"else if self:singlevaraux(as.prev,t,b2,0)=="VGLOBAL"then return"VGLOBAL"end;b2.info=self:indexupvalue(as,t,b2)b2.k="VUPVAL"return"VUPVAL"end end end;function d:singlevar(H,b2)local bq=self:str_checkname(H)local as=H.fs;if self:singlevaraux(as,bq,b2,1)=="VGLOBAL"then b2.info=h:stringK(as,bq)end end;function d:adjust_assign(H,bs,bx,at)local as=H.fs;local by=bs-bx;if self:hasmultret(at.k)then by=by+1;if by<=0 then by=0 end;h:setreturns(as,at,by)if by>1 then h:reserveregs(as,by-1)end else if at.k~="VVOID"then h:exp2nextreg(as,at)end;if by>0 then local aM=as.freereg;h:reserveregs(as,by)h:_nil(as,aM,by)end end end;function d:enterlevel(H)H.L.nCcalls=H.L.nCcalls+1;if H.L.nCcalls>self.LUAI_MAXCCALLS then e:lexerror(H,"chunk has too many syntax levels",0)end end;function d:leavelevel(H)H.L.nCcalls=H.L.nCcalls-1 end;function d:enterblock(as,bw,bz)bw.breaklist=h.NO_JUMP;bw.isbreakable=bz;bw.nactvar=as.nactvar;bw.upval=false;bw.previous=as.bl;as.bl=bw;j(as.freereg==as.nactvar)end;function d:leaveblock(as)local bw=as.bl;as.bl=bw.previous;self:removevars(as.ls,bw.nactvar)if bw.upval then h:codeABC(as,"OP_CLOSE",bw.nactvar,0,0)end;j(not bw.isbreakable or not bw.upval)j(bw.nactvar==as.nactvar)as.freereg=as.nactvar;h:patchtohere(as,bw.breaklist)end;function d:pushclosure(H,b5,y)local as=H.fs;local ao=as.f;self:growvector(H.L,ao.p,as.np,ao.sizep,nil,f.MAXARG_Bx,"constant table overflow")ao.p[as.np]=b5.f;as.np=as.np+1;self:init_exp(y,"VRELOCABLE",h:codeABx(as,"OP_CLOSURE",0,as.np-1))for Z=0,b5.f.nups-1 do local a0=b5.upvalues[Z].k=="VLOCAL"and"OP_MOVE"or"OP_GETUPVAL"h:codeABC(as,a0,0,b5.upvalues[Z].info,0)end end;function d:open_func(H,as)local M=H.L;local ao=self:newproto(H.L)as.f=ao;as.prev=H.fs;as.ls=H;as.L=M;H.fs=as;as.pc=0;as.lasttarget=-1;as.jpc=h.NO_JUMP;as.freereg=0;as.nk=0;as.np=0;as.nlocvars=0;as.nactvar=0;as.bl=nil;ao.source=H.source;ao.maxstacksize=2;as.h={}end;function d:close_func(H)local M=H.L;local as=H.fs;local ao=as.f;self:removevars(H,0)h:ret(as,0,0)ao.sizecode=as.pc;ao.sizelineinfo=as.pc;ao.sizek=as.nk;ao.sizep=as.np;ao.sizelocvars=as.nlocvars;ao.sizeupvalues=ao.nups;j(as.bl==nil)H.fs=as.prev;if as then self:anchor_token(H)end end;function d:parser(M,s,l,name)local bA={}bA.t={}bA.lookahead={}local bB={}bB.upvalues={}bB.actvar={}M.nCcalls=0;bA.buff=l;e:setinput(M,bA,s,name)self:open_func(bA,bB)bB.f.is_vararg=self.VARARG_ISVARARG;e:next(bA)self:chunk(bA)self:check(bA,"TK_EOS")self:close_func(bA)j(bB.prev==nil)j(bB.f.nups==0)j(bA.fs==nil)return bB.f end;function d:field(H,y)local as=H.fs;local b4={}h:exp2anyreg(as,y)e:next(H)self:checkname(H,b4)h:indexed(as,y,b4)end;function d:yindex(H,y)e:next(H)self:expr(H,y)h:exp2val(H.fs,y)self:checknext(H,"]")end;function d:recfield(H,bC)local as=H.fs;local aM=H.fs.freereg;local b4,bD={},{}if H.t.token=="TK_NAME"then self:checklimit(as,bC.nh,self.MAX_INT,"items in a constructor")self:checkname(H,b4)else self:yindex(H,b4)end;bC.nh=bC.nh+1;self:checknext(H,"=")local bE=h:exp2RK(as,b4)self:expr(H,bD)h:codeABC(as,"OP_SETTABLE",bC.t.info,bE,h:exp2RK(as,bD))as.freereg=aM end;function d:closelistfield(as,bC)if bC.v.k=="VVOID"then return end;h:exp2nextreg(as,bC.v)bC.v.k="VVOID"if bC.tostore==f.LFIELDS_PER_FLUSH then h:setlist(as,bC.t.info,bC.na,bC.tostore)bC.tostore=0 end end;function d:lastlistfield(as,bC)if bC.tostore==0 then return end;if self:hasmultret(bC.v.k)then h:setmultret(as,bC.v)h:setlist(as,bC.t.info,bC.na,self.LUA_MULTRET)bC.na=bC.na-1 else if bC.v.k~="VVOID"then h:exp2nextreg(as,bC.v)end;h:setlist(as,bC.t.info,bC.na,bC.tostore)end end;function d:listfield(H,bC)self:expr(H,bC.v)self:checklimit(H.fs,bC.na,self.MAX_INT,"items in a constructor")bC.na=bC.na+1;bC.tostore=bC.tostore+1 end;function d:constructor(H,ae)local as=H.fs;local bh=H.linenumber;local aE=h:codeABC(as,"OP_NEWTABLE",0,0,0)local bC={}bC.v={}bC.na,bC.nh,bC.tostore=0,0,0;bC.t=ae;self:init_exp(ae,"VRELOCABLE",aE)self:init_exp(bC.v,"VVOID",0)h:exp2nextreg(H.fs,ae)self:checknext(H,"{")repeat j(bC.v.k=="VVOID"or bC.tostore>0)if H.t.token=="}"then break end;self:closelistfield(as,bC)local O=H.t.token;if O=="TK_NAME"then e:lookahead(H)if H.lookahead.token~="="then self:listfield(H,bC)else self:recfield(H,bC)end elseif O=="["then self:recfield(H,bC)else self:listfield(H,bC)end until not self:testnext(H,",")and not self:testnext(H,";")self:check_match(H,"}","{",bh)self:lastlistfield(as,bC)f:SETARG_B(as.f.code[aE],self:int2fb(bC.na))f:SETARG_C(as.f.code[aE],self:int2fb(bC.nh))end;function d:parlist(H)local as=H.fs;local ao=as.f;local bF=0;ao.is_vararg=0;if H.t.token~=")"then repeat local O=H.t.token;if O=="TK_NAME"then self:new_localvar(H,self:str_checkname(H),bF)bF=bF+1 elseif O=="TK_DOTS"then e:next(H)self:new_localvarliteral(H,"arg",bF)bF=bF+1;ao.is_vararg=self.VARARG_HASARG+self.VARARG_NEEDSARG;ao.is_vararg=ao.is_vararg+self.VARARG_ISVARARG else e:syntaxerror(H,"<name> or "..self:LUA_QL("...").." expected")end until ao.is_vararg~=0 or not self:testnext(H,",")end;self:adjustlocalvars(H,bF)ao.numparams=as.nactvar-ao.is_vararg%self.HASARG_MASK;h:reserveregs(as,as.nactvar)end;function d:body(H,at,bG,bh)local bH={}bH.upvalues={}bH.actvar={}self:open_func(H,bH)bH.f.lineDefined=bh;self:checknext(H,"(")if bG then self:new_localvarliteral(H,"self",0)self:adjustlocalvars(H,1)end;self:parlist(H)self:checknext(H,")")self:chunk(H)bH.f.lastlinedefined=H.linenumber;self:check_match(H,"TK_END","TK_FUNCTION",bh)self:close_func(H)self:pushclosure(H,bH,at)end;function d:explist1(H,y)local t=1;self:expr(H,y)while self:testnext(H,",")do h:exp2nextreg(H.fs,y)self:expr(H,y)t=t+1 end;return t end;function d:funcargs(H,ao)local as=H.fs;local bI={}local bF;local bh=H.linenumber;local O=H.t.token;if O=="("then if bh~=H.lastline then e:syntaxerror(H,"ambiguous syntax (function call x new statement)")end;e:next(H)if H.t.token==")"then bI.k="VVOID"else self:explist1(H,bI)h:setmultret(as,bI)end;self:check_match(H,")","(",bh)elseif O=="{"then self:constructor(H,bI)elseif O=="TK_STRING"then self:codestring(H,bI,H.t.seminfo)e:next(H)else e:syntaxerror(H,"function arguments expected")return end;j(ao.k=="VNONRELOC")local bi=ao.info;if self:hasmultret(bI.k)then bF=self.LUA_MULTRET else if bI.k~="VVOID"then h:exp2nextreg(as,bI)end;bF=as.freereg-(bi+1)end;self:init_exp(ao,"VCALL",h:codeABC(as,"OP_CALL",bi,bF+1,2))h:fixline(as,bh)as.freereg=bi+1 end;function d:prefixexp(H,y)local O=H.t.token;if O=="("then local bh=H.linenumber;e:next(H)self:expr(H,y)self:check_match(H,")","(",bh)h:dischargevars(H.fs,y)elseif O=="TK_NAME"then self:singlevar(H,y)else e:syntaxerror(H,"unexpected symbol")end;return end;function d:primaryexp(H,y)local as=H.fs;self:prefixexp(H,y)while true do local O=H.t.token;if O=="."then self:field(H,y)elseif O=="["then local b4={}h:exp2anyreg(as,y)self:yindex(H,b4)h:indexed(as,y,b4)elseif O==":"then local b4={}e:next(H)self:checkname(H,b4)h:_self(as,y,b4)self:funcargs(H,y)elseif O=="("or O=="TK_STRING"or O=="{"then h:exp2nextreg(as,y)self:funcargs(H,y)else return end end end;function d:simpleexp(H,y)local O=H.t.token;if O=="TK_NUMBER"then self:init_exp(y,"VKNUM",0)y.nval=H.t.seminfo elseif O=="TK_STRING"then self:codestring(H,y,H.t.seminfo)elseif O=="TK_NIL"then self:init_exp(y,"VNIL",0)elseif O=="TK_TRUE"then self:init_exp(y,"VTRUE",0)elseif O=="TK_FALSE"then self:init_exp(y,"VFALSE",0)elseif O=="TK_DOTS"then local as=H.fs;self:check_condition(H,as.f.is_vararg~=0,"cannot use "..self:LUA_QL("...").." outside a vararg function")local bJ=as.f.is_vararg;if bJ>=self.VARARG_NEEDSARG then as.f.is_vararg=bJ-self.VARARG_NEEDSARG end;self:init_exp(y,"VVARARG",h:codeABC(as,"OP_VARARG",0,1,0))elseif O=="{"then self:constructor(H,y)return elseif O=="TK_FUNCTION"then e:next(H)self:body(H,y,false,H.linenumber)return else self:primaryexp(H,y)return end;e:next(H)end;function d:getunopr(aa)if aa=="TK_NOT"then return"OPR_NOT"elseif aa=="-"then return"OPR_MINUS"elseif aa=="#"then return"OPR_LEN"else return"OPR_NOUNOPR"end end;d.getbinopr_table={["+"]="OPR_ADD",["-"]="OPR_SUB",["*"]="OPR_MUL",["/"]="OPR_DIV",["%"]="OPR_MOD",["^"]="OPR_POW",["TK_CONCAT"]="OPR_CONCAT",["TK_NE"]="OPR_NE",["TK_EQ"]="OPR_EQ",["<"]="OPR_LT",["TK_LE"]="OPR_LE",[">"]="OPR_GT",["TK_GE"]="OPR_GE",["TK_AND"]="OPR_AND",["TK_OR"]="OPR_OR"}function d:getbinopr(aa)local bK=self.getbinopr_table[aa]if bK then return bK else return"OPR_NOBINOPR"end end;d.priority={{6,6},{6,6},{7,7},{7,7},{7,7},{10,9},{5,4},{3,3},{3,3},{3,3},{3,3},{3,3},{3,3},{2,2},{1,1}}d.UNARY_PRIORITY=8;function d:subexpr(H,y,bm)self:enterlevel(H)local bL=self:getunopr(H.t.token)if bL~="OPR_NOUNOPR"then e:next(H)self:subexpr(H,y,self.UNARY_PRIORITY)h:prefix(H.fs,bL,y)else self:simpleexp(H,y)end;local aa=self:getbinopr(H.t.token)while aa~="OPR_NOBINOPR"and self.priority[h.BinOpr[aa]+1][1]>bm do local bb={}e:next(H)h:infix(H.fs,aa,y)local bM=self:subexpr(H,bb,self.priority[h.BinOpr[aa]+1][2])h:posfix(H.fs,aa,y,bb)aa=bM end;self:leavelevel(H)return aa end;function d:expr(H,y)self:subexpr(H,y,0)end;function d:block_follow(I)if I=="TK_ELSE"or I=="TK_ELSEIF"or I=="TK_END"or I=="TK_UNTIL"or I=="TK_EOS"then return true else return false end end;function d:block(H)local as=H.fs;local bw={}self:enterblock(as,bw,false)self:chunk(H)j(bw.breaklist==h.NO_JUMP)self:leaveblock(as)end;function d:check_conflict(H,bN,y)local as=H.fs;local by=as.freereg;local bO=false;while bN do if bN.v.k=="VINDEXED"then if bN.v.info==y.info then bO=true;bN.v.info=by end;if bN.v.aux==y.info then bO=true;bN.v.aux=by end end;bN=bN.prev end;if bO then h:codeABC(as,"OP_MOVE",as.freereg,y.info,0)h:reserveregs(as,1)end end;function d:assignment(H,bN,bs)local at={}local O=bN.v.k;self:check_condition(H,O=="VLOCAL"or O=="VUPVAL"or O=="VGLOBAL"or O=="VINDEXED","syntax error")if self:testnext(H,",")then local bP={}bP.v={}bP.prev=bN;self:primaryexp(H,bP.v)if bP.v.k=="VLOCAL"then self:check_conflict(H,bN,bP.v)end;self:checklimit(H.fs,bs,self.LUAI_MAXCCALLS-H.L.nCcalls,"variables in assignment")self:assignment(H,bP,bs+1)else self:checknext(H,"=")local bx=self:explist1(H,at)if bx~=bs then self:adjust_assign(H,bs,bx,at)if bx>bs then H.fs.freereg=H.fs.freereg-(bx-bs)end else h:setoneret(H.fs,at)h:storevar(H.fs,bN.v,at)return end end;self:init_exp(at,"VNONRELOC",H.fs.freereg-1)h:storevar(H.fs,bN.v,at)end;function d:cond(H)local y={}self:expr(H,y)if y.k=="VNIL"then y.k="VFALSE"end;h:goiftrue(H.fs,y)return y.f end;function d:breakstat(H)local as=H.fs;local bw=as.bl;local bQ=false;while bw and not bw.isbreakable do if bw.upval then bQ=true end;bw=bw.previous end;if not bw then e:syntaxerror(H,"no loop to break")end;if bQ then h:codeABC(as,"OP_CLOSE",bw.nactvar,0,0)end;bw.breaklist=h:concat(as,bw.breaklist,h:jump(as))end;function d:whilestat(H,bh)local as=H.fs;local bw={}e:next(H)local bR=h:getlabel(as)local bS=self:cond(H)self:enterblock(as,bw,true)self:checknext(H,"TK_DO")self:block(H)h:patchlist(as,h:jump(as),bR)self:check_match(H,"TK_END","TK_WHILE",bh)self:leaveblock(as)h:patchtohere(as,bS)end;function d:repeatstat(H,bh)local as=H.fs;local bT=h:getlabel(as)local bU,bV={},{}self:enterblock(as,bU,true)self:enterblock(as,bV,false)e:next(H)self:chunk(H)self:check_match(H,"TK_UNTIL","TK_REPEAT",bh)local bS=self:cond(H)if not bV.upval then self:leaveblock(as)h:patchlist(H.fs,bS,bT)else self:breakstat(H)h:patchtohere(H.fs,bS)self:leaveblock(as)h:patchlist(H.fs,h:jump(as),bT)end;self:leaveblock(as)end;function d:exp1(H)local at={}self:expr(H,at)local aU=at.k;h:exp2nextreg(H.fs,at)return aU end;function d:forbody(H,bi,bh,bs,bW)local bw={}local as=H.fs;self:adjustlocalvars(H,3)self:checknext(H,"TK_DO")local bX=bW and h:codeAsBx(as,"OP_FORPREP",bi,h.NO_JUMP)or h:jump(as)self:enterblock(as,bw,false)self:adjustlocalvars(H,bs)h:reserveregs(as,bs)self:block(H)self:leaveblock(as)h:patchtohere(as,bX)local bY=bW and h:codeAsBx(as,"OP_FORLOOP",bi,h.NO_JUMP)or h:codeABC(as,"OP_TFORLOOP",bi,0,bs)h:fixline(as,bh)h:patchlist(as,bW and bY or h:jump(as),bX+1)end;function d:fornum(H,bq,bh)local as=H.fs;local bi=as.freereg;self:new_localvarliteral(H,"(for index)",0)self:new_localvarliteral(H,"(for limit)",1)self:new_localvarliteral(H,"(for step)",2)self:new_localvar(H,bq,3)self:checknext(H,'=')self:exp1(H)self:checknext(H,",")self:exp1(H)if self:testnext(H,",")then self:exp1(H)else h:codeABx(as,"OP_LOADK",as.freereg,h:numberK(as,1))h:reserveregs(as,1)end;self:forbody(H,bi,bh,1,true)end;function d:forlist(H,bZ)local as=H.fs;local at={}local bs=0;local bi=as.freereg;self:new_localvarliteral(H,"(for generator)",bs)bs=bs+1;self:new_localvarliteral(H,"(for state)",bs)bs=bs+1;self:new_localvarliteral(H,"(for control)",bs)bs=bs+1;self:new_localvar(H,bZ,bs)bs=bs+1;while self:testnext(H,",")do self:new_localvar(H,self:str_checkname(H),bs)bs=bs+1 end;self:checknext(H,"TK_IN")local bh=H.linenumber;self:adjust_assign(H,3,self:explist1(H,at),at)h:checkstack(as,3)self:forbody(H,bi,bh,bs-3,false)end;function d:forstat(H,bh)local as=H.fs;local bw={}self:enterblock(as,bw,true)e:next(H)local bq=self:str_checkname(H)local O=H.t.token;if O=="="then self:fornum(H,bq,bh)elseif O==","or O=="TK_IN"then self:forlist(H,bq)else e:syntaxerror(H,self:LUA_QL("=").." or "..self:LUA_QL("in").." expected")end;self:check_match(H,"TK_END","TK_FOR",bh)self:leaveblock(as)end;function d:test_then_block(H)e:next(H)local bS=self:cond(H)self:checknext(H,"TK_THEN")self:block(H)return bS end;function d:ifstat(H,bh)local as=H.fs;local b_=h.NO_JUMP;local c0=self:test_then_block(H)while H.t.token=="TK_ELSEIF"do b_=h:concat(as,b_,h:jump(as))h:patchtohere(as,c0)c0=self:test_then_block(H)end;if H.t.token=="TK_ELSE"then b_=h:concat(as,b_,h:jump(as))h:patchtohere(as,c0)e:next(H)self:block(H)else b_=h:concat(as,b_,c0)end;h:patchtohere(as,b_)self:check_match(H,"TK_END","TK_IF",bh)end;function d:localfunc(H)local y,m={},{}local as=H.fs;self:new_localvar(H,self:str_checkname(H),0)self:init_exp(y,"VLOCAL",as.freereg)h:reserveregs(as,1)self:adjustlocalvars(H,1)self:body(H,m,false,H.linenumber)h:storevar(as,y,m)self:getlocvar(as,as.nactvar-1).startpc=as.pc end;function d:localstat(H)local bs=0;local bx;local at={}repeat self:new_localvar(H,self:str_checkname(H),bs)bs=bs+1 until not self:testnext(H,",")if self:testnext(H,"=")then bx=self:explist1(H,at)else at.k="VVOID"bx=0 end;self:adjust_assign(H,bs,bx,at)self:adjustlocalvars(H,bs)end;function d:funcname(H,y)local bG=false;self:singlevar(H,y)while H.t.token=="."do self:field(H,y)end;if H.t.token==":"then bG=true;self:field(H,y)end;return bG end;function d:funcstat(H,bh)local y,m={},{}e:next(H)local bG=self:funcname(H,y)self:body(H,m,bG,bh)h:storevar(H.fs,y,m)h:fixline(H.fs,bh)end;function d:exprstat(H)local as=H.fs;local y={}y.v={}self:primaryexp(H,y.v)if y.v.k=="VCALL"then f:SETARG_C(h:getcode(as,y.v),1)else y.prev=nil;self:assignment(H,y,1)end end;function d:retstat(H)local as=H.fs;local at={}local E,aB;e:next(H)if self:block_follow(H.t.token)or H.t.token==";"then E,aB=0,0 else aB=self:explist1(H,at)if self:hasmultret(at.k)then h:setmultret(as,at)if at.k=="VCALL"and aB==1 then f:SET_OPCODE(h:getcode(as,at),"OP_TAILCALL")j(f:GETARG_A(h:getcode(as,at))==as.nactvar)end;E=as.nactvar;aB=self.LUA_MULTRET else if aB==1 then E=h:exp2anyreg(as,at)else h:exp2nextreg(as,at)E=as.nactvar;j(aB==as.freereg-E)end end end;h:ret(as,E,aB)end;function d:statement(H)local bh=H.linenumber;local O=H.t.token;if O=="TK_IF"then self:ifstat(H,bh)return false elseif O=="TK_WHILE"then self:whilestat(H,bh)return false elseif O=="TK_DO"then e:next(H)self:block(H)self:check_match(H,"TK_END","TK_DO",bh)return false elseif O=="TK_FOR"then self:forstat(H,bh)return false elseif O=="TK_REPEAT"then self:repeatstat(H,bh)return false elseif O=="TK_FUNCTION"then self:funcstat(H,bh)return false elseif O=="TK_LOCAL"then e:next(H)if self:testnext(H,"TK_FUNCTION")then self:localfunc(H)else self:localstat(H)end;return false elseif O=="TK_RETURN"then self:retstat(H)return true elseif O=="TK_BREAK"then e:next(H)self:breakstat(H)return true else self:exprstat(H)return false end end;function d:chunk(H)local c1=false;self:enterlevel(H)while not c1 and not self:block_follow(H.t.token)do c1=self:statement(H)self:testnext(H,";")j(H.fs.f.maxstacksize>=H.fs.freereg and H.fs.freereg>=H.fs.nactvar)H.fs.freereg=H.fs.nactvar end;self:leavelevel(H)end;e:init()local c2={}return function(o,name)name=name or'compiled-lua'local c3=c:init(c:make_getF(o),nil)if not c3 then return end;local b5=d:parser(c2,c3,nil,"@"..name)local af,l=g:make_setS()g:dump(c2,b5,af,l)return l.data end end)()local c4=(function(...)local bit=bit or bit32 or require('bit')if not table.create then function table.create(c)return{}end end;if not table.unpack then table.unpack=unpack end;if not table.pack then function table.pack(...)return{n=select('#',...),...}end end;if not table.move then function table.move(d,e,f,g,h)for i=0,f-e do h[g+i]=d[e+i]end end end;local j;local k;local l;local m=50;local n={[22]=18,[31]=8,[33]=28,[0]=3,[1]=13,[2]=23,[26]=33,[12]=1,[13]=6,[14]=10,[15]=16,[16]=20,[17]=26,[18]=30,[19]=36,[3]=0,[4]=2,[5]=4,[6]=7,[7]=9,[8]=12,[9]=14,[10]=17,[20]=19,[21]=22,[23]=24,[24]=27,[25]=29,[27]=32,[32]=34,[34]=37,[11]=5,[28]=11,[29]=15,[30]=21,[35]=25,[36]=31,[37]=35}local o={[0]='ABC','ABx','ABC','ABC','ABC','ABx','ABC','ABx','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','AsBx','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','AsBx','AsBx','ABC','ABC','ABC','ABx','ABC'}local p={[0]={b='OpArgR',c='OpArgN'},{b='OpArgK',c='OpArgN'},{b='OpArgU',c='OpArgU'},{b='OpArgR',c='OpArgN'},{b='OpArgU',c='OpArgN'},{b='OpArgK',c='OpArgN'},{b='OpArgR',c='OpArgK'},{b='OpArgK',c='OpArgN'},{b='OpArgU',c='OpArgN'},{b='OpArgK',c='OpArgK'},{b='OpArgU',c='OpArgU'},{b='OpArgR',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgR',c='OpArgN'},{b='OpArgR',c='OpArgN'},{b='OpArgR',c='OpArgN'},{b='OpArgR',c='OpArgR'},{b='OpArgR',c='OpArgN'},{b='OpArgK',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgR',c='OpArgU'},{b='OpArgR',c='OpArgU'},{b='OpArgU',c='OpArgU'},{b='OpArgU',c='OpArgU'},{b='OpArgU',c='OpArgN'},{b='OpArgR',c='OpArgN'},{b='OpArgR',c='OpArgN'},{b='OpArgN',c='OpArgU'},{b='OpArgU',c='OpArgU'},{b='OpArgN',c='OpArgN'},{b='OpArgU',c='OpArgN'},{b='OpArgU',c='OpArgN'}}local function q(d,r,s,t)local u=0;for i=r,s,t do local v=256^math.abs(i-r)u=u+v*string.byte(d,i,i)end;return u end;local function w(y,z,x,A)local B=(-1)^bit.rshift(A,7)local C=bit.rshift(x,7)+bit.lshift(bit.band(A,0x7F),1)local D=y+bit.lshift(z,8)+bit.lshift(bit.band(x,0x7F),16)local E=1;if C==0 then if D==0 then return B*0 else E=0;C=1 end elseif C==0x7F then if D==0 then return B*1/0 else return B*0/0 end end;return B*2^(C-127)*(1+E/2^23)end;local function F(y,z,x,A,G,H,I,J)local B=(-1)^bit.rshift(J,7)local C=bit.lshift(bit.band(J,0x7F),4)+bit.rshift(I,4)local D=bit.band(I,0x0F)*2^48;local E=1;D=D+H*2^40+G*2^32+A*2^24+x*2^16+z*2^8+y;if C==0 then if D==0 then return B*0 else E=0;C=1 end elseif C==0x7FF then if D==0 then return B*1/0 else return B*0/0 end end;return B*2^(C-1023)*(E+D/2^52)end;local function K(d,r,s)return q(d,r,s-1,1)end;local function L(d,r,s)return q(d,s-1,r,-1)end;local function M(d,r)return w(string.byte(d,r,r+3))end;local function N(d,r)local y,z,x,A=string.byte(d,r,r+3)return w(A,x,z,y)end;local function O(d,r)return F(string.byte(d,r,r+7))end;local function P(d,r)local y,z,x,A,G,H,I,J=string.byte(d,r,r+7)return F(J,I,H,G,A,x,z,y)end;local Q={[4]={little=M,big=N},[8]={little=O,big=P}}local function R(S)local T=S.index;local U=string.byte(S.source,T,T)S.index=T+1;return U end;local function V(S,W)local X=S.index+W;local Y=string.sub(S.source,S.index,X-1)S.index=X;return Y end;local function Z(S)local W=S:s_szt()local Y;if W~=0 then Y=string.sub(V(S,W),1,-2)end;return Y end;local function _(W,a0)return function(S)local X=S.index+W;local a1=a0(S.source,S.index,X)S.index=X;return a1 end end;local function a2(W,a0)return function(S)local a3=a0(S.source,S.index)S.index=S.index+W;return a3 end end;local function a4(S)local W=S:s_int()local a5=table.create(W)for i=1,W do local a6=S:s_ins()local a7=bit.band(a6,0x3F)local a8=o[a7]local a9=p[a7]local aa={value=a6,op=n[a7],A=bit.band(bit.rshift(a6,6),0xFF)}if a8=='ABC'then aa.B=bit.band(bit.rshift(a6,23),0x1FF)aa.C=bit.band(bit.rshift(a6,14),0x1FF)aa.is_KB=a9.b=='OpArgK'and aa.B>0xFF;aa.is_KC=a9.c=='OpArgK'and aa.C>0xFF elseif a8=='ABx'then aa.Bx=bit.band(bit.rshift(a6,14),0x3FFFF)aa.is_K=a9.b=='OpArgK'elseif a8=='AsBx'then aa.sBx=bit.band(bit.rshift(a6,14),0x3FFFF)-131071 end;a5[i]=aa end;return a5 end;local function ab(S)local W=S:s_int()local a5=table.create(W)for i=1,W do local ac=R(S)local ad;if ac==1 then ad=R(S)~=0 elseif ac==3 then ad=S:s_num()elseif ac==4 then ad=Z(S)end;a5[i]=ad end;return a5 end;local function ae(S,d)local W=S:s_int()local a5=table.create(W)for i=1,W do a5[i]=l(S,d)end;return a5 end;local function af(S)local W=S:s_int()local a5=table.create(W)for i=1,W do a5[i]=S:s_int()end;return a5 end;local function ag(S)local W=S:s_int()local a5=table.create(W)for i=1,W do a5[i]={varname=Z(S),startpc=S:s_int(),endpc=S:s_int()}end;return a5 end;local function ah(S)local W=S:s_int()local a5=table.create(W)for i=1,W do a5[i]=Z(S)end;return a5 end;function l(S,ai)local aj={}local d=Z(S)or ai;aj.source=d;S:s_int()S:s_int()aj.num_upval=R(S)aj.num_param=R(S)R(S)aj.max_stack=R(S)aj.code=a4(S)aj.const=ab(S)aj.subs=ae(S,d)aj.lines=af(S)ag(S)ah(S)for c,ak in ipairs(aj.code)do if ak.is_K then ak.const=aj.const[ak.Bx+1]else if ak.is_KB then ak.const_B=aj.const[ak.B-0xFF]end;if ak.is_KC then ak.const_C=aj.const[ak.C-0xFF]end end end;return aj end;function j(d)local al;local am;local an;local ao;local ap;local aq;local ar;local as={index=1,source=d}assert(V(as,4)=='\27Lua','invalid Lua signature')assert(R(as)==0x51,'invalid Lua version')assert(R(as)==0,'invalid Lua format')am=R(as)~=0;an=R(as)ao=R(as)ap=R(as)aq=R(as)ar=R(as)~=0;al=am and K or L;as.s_int=_(an,al)as.s_szt=_(ao,al)as.s_ins=_(ap,al)if ar then as.s_num=_(aq,al)elseif Q[aq]then as.s_num=a2(aq,Q[aq][am and'little'or'big'])else error('unsupported float size')end;return l(as,'@virtual')end;local function at(a5,au)for i,av in pairs(a5)do if av.index>=au then av.value=av.store[av.index]av.store=av;av.index='value'a5[i]=nil end end end;local function aw(a5,au,ax)local ay=a5[au]if not ay then ay={index=au,store=ax}a5[au]=ay end;return ay end;local function az(aA,aB)local d=aA.source;local aC=aA.lines[aA.pc-1]error(string.format('%s:%i: %s',d,aC,aB),0)end;local function aD(aE,aF,aG)local aH=aE.code;local aI=aE.subs;local aJ=aE.vararg;local aK=-1;local aL={}local ax=aE.memory;local aM=aE.pc;while true do local aN=aH[aM]local a7=aN.op;aM=aM+1;if a7<18 then if a7<8 then if a7<3 then if a7<1 then for i=aN.A,aN.B do ax[i]=nil end elseif a7>1 then local av=aG[aN.B]ax[aN.A]=av.store[av.index]else local aO,aP;if aN.is_KB then aO=aN.const_B else aO=ax[aN.B]end;if aN.is_KC then aP=aN.const_C else aP=ax[aN.C]end;ax[aN.A]=aO+aP end elseif a7>3 then if a7<6 then if a7>4 then local aQ=aN.A;local aR=aN.B;local au;if aN.is_KC then au=aN.const_C else au=ax[aN.C]end;ax[aQ+1]=ax[aR]ax[aQ]=ax[aR][au]else ax[aN.A]=aF[aN.const]end elseif a7>6 then local au;if aN.is_KC then au=aN.const_C else au=ax[aN.C]end;ax[aN.A]=ax[aN.B][au]else local aO,aP;if aN.is_KB then aO=aN.const_B else aO=ax[aN.B]end;if aN.is_KC then aP=aN.const_C else aP=ax[aN.C]end;ax[aN.A]=aO-aP end else ax[aN.A]=ax[aN.B]end elseif a7>8 then if a7<13 then if a7<10 then aF[aN.const]=ax[aN.A]elseif a7>10 then if a7<12 then local aQ=aN.A;local aR=aN.B;local aS=aN.C;local aT;if aR==0 then aT=aK-aQ else aT=aR-1 end;local aU=table.pack(ax[aQ](table.unpack(ax,aQ+1,aQ+aT)))local aV=aU.n;if aS==0 then aK=aQ+aV-1 else aV=aS-1 end;table.move(aU,1,aV,aQ,ax)else local av=aG[aN.B]av.store[av.index]=ax[aN.A]end else local aO,aP;if aN.is_KB then aO=aN.const_B else aO=ax[aN.B]end;if aN.is_KC then aP=aN.const_C else aP=ax[aN.C]end;ax[aN.A]=aO*aP end elseif a7>13 then if a7<16 then if a7>14 then local aQ=aN.A;local aR=aN.B;local aT;if aR==0 then aT=aK-aQ else aT=aR-1 end;at(aL,0)return ax[aQ](table.unpack(ax,aQ+1,aQ+aT))else local au,aW;if aN.is_KB then au=aN.const_B else au=ax[aN.B]end;if aN.is_KC then aW=aN.const_C else aW=ax[aN.C]end;ax[aN.A][au]=aW end elseif a7>16 then ax[aN.A]={}else local aO,aP;if aN.is_KB then aO=aN.const_B else aO=ax[aN.B]end;if aN.is_KC then aP=aN.const_C else aP=ax[aN.C]end;ax[aN.A]=aO/aP end else ax[aN.A]=aN.const end else local aQ=aN.A;local aX=ax[aQ+2]local au=ax[aQ]+aX;local aY=ax[aQ+1]local aZ;if aX==math.abs(aX)then aZ=au<=aY else aZ=au>=aY end;if aZ then ax[aN.A]=au;ax[aN.A+3]=au;aM=aM+aN.sBx end end elseif a7>18 then if a7<28 then if a7<23 then if a7<20 then ax[aN.A]=#ax[aN.B]elseif a7>20 then if a7<22 then local aQ=aN.A;local aR=aN.B;local W;if aR==0 then W=aK-aQ+1 else W=aR-1 end;at(aL,0)return table.unpack(ax,aQ,aQ+W-1)else local Y=ax[aN.B]for i=aN.B+1,aN.C do Y=Y..ax[i]end;ax[aN.A]=Y end else local aO,aP;if aN.is_KB then aO=aN.const_B else aO=ax[aN.B]end;if aN.is_KC then aP=aN.const_C else aP=ax[aN.C]end;ax[aN.A]=aO%aP end elseif a7>23 then if a7<26 then if a7>24 then at(aL,aN.A)else local aO,aP;if aN.is_KB then aO=aN.const_B else aO=ax[aN.B]end;if aN.is_KC then aP=aN.const_C else aP=ax[aN.C]end;if aO==aP==(aN.A~=0)then aM=aM+aH[aM].sBx end;aM=aM+1 end elseif a7>26 then local aO,aP;if aN.is_KB then aO=aN.const_B else aO=ax[aN.B]end;if aN.is_KC then aP=aN.const_C else aP=ax[aN.C]end;if aO<aP==(aN.A~=0)then aM=aM+aH[aM].sBx end;aM=aM+1 else local aO,aP;if aN.is_KB then aO=aN.const_B else aO=ax[aN.B]end;if aN.is_KC then aP=aN.const_C else aP=ax[aN.C]end;ax[aN.A]=aO^aP end else ax[aN.A]=aN.B~=0;if aN.C~=0 then aM=aM+1 end end elseif a7>28 then if a7<33 then if a7<30 then local aO,aP;if aN.is_KB then aO=aN.const_B else aO=ax[aN.B]end;if aN.is_KC then aP=aN.const_C else aP=ax[aN.C]end;if aO<=aP==(aN.A~=0)then aM=aM+aH[aM].sBx end;aM=aM+1 elseif a7>30 then if a7<32 then local a_=aI[aN.Bx+1]local b0=a_.num_upval;local b1;if b0~=0 then b1={}for i=1,b0 do local b2=aH[aM+i-1]if b2.op==n[0]then b1[i-1]=aw(aL,b2.B,ax)elseif b2.op==n[4]then b1[i-1]=aG[b2.B]end end;aM=aM+b0 end;ax[aN.A]=k(a_,aF,b1)else local aQ=aN.A;local aR=aN.B;if not ax[aR]~=(aN.C~=0)then ax[aQ]=ax[aR]aM=aM+aH[aM].sBx end;aM=aM+1 end else ax[aN.A]=-ax[aN.B]end elseif a7>33 then if a7<36 then if a7>34 then local aQ=aN.A;local W=aN.B;if W==0 then W=aJ.len;aK=aQ+W-1 end;table.move(aJ.list,1,W,aQ,ax)else local aQ=aN.A;local b3,aY,aX;b3=assert(tonumber(ax[aQ]),'`for` initial value must be a number')aY=assert(tonumber(ax[aQ+1]),'`for` limit must be a number')aX=assert(tonumber(ax[aQ+2]),'`for` step must be a number')ax[aQ]=b3-aX;ax[aQ+1]=aY;ax[aQ+2]=aX;aM=aM+aN.sBx end elseif a7>36 then local aQ=aN.A;local aS=aN.C;local W=aN.B;local b4=ax[aQ]local g;if W==0 then W=aK-aQ end;if aS==0 then aS=aN[aM].value;aM=aM+1 end;g=(aS-1)*m;table.move(ax,aQ+1,aQ+W,g+1,b4)else ax[aN.A]=not ax[aN.B]end else if not ax[aN.A]~=(aN.C~=0)then aM=aM+aH[aM].sBx end;aM=aM+1 end else local aQ=aN.A;local b5=aQ+3;local b6={ax[aQ](ax[aQ+1],ax[aQ+2])}table.move(b6,1,aN.C,b5,ax)if ax[b5]~=nil then ax[aQ+2]=ax[b5]aM=aM+aH[aM].sBx end;aM=aM+1 end else aM=aM+aN.sBx end;aE.pc=aM end end;function k(aj,aF,b7)local function b8(...)local b9=table.pack(...)local ax=table.create(aj.max_stack)local aJ={len=0,list={}}table.move(b9,1,aj.num_param,0,ax)if aj.num_param<b9.n then local ba=aj.num_param+1;local W=b9.n-aj.num_param;aJ.len=W;table.move(b9,ba,ba+W-1,1,aJ.list)end;local aE={vararg=aJ,memory=ax,code=aj.code,subs=aj.subs,pc=1}local bb=table.pack(pcall(aD,aE,aF,b7))if bb[1]then return table.unpack(bb,2,bb.n)else local aA={pc=aE.pc,source=aj.source,lines=aj.lines}az(aA,bb[2])return end end;return b8 end;return function(bc,aF)return k(j(bc),aF or getfenv(0))end end)()getfenv().script=nil;return function(c5,c6)local c7;local c6=c6 or getfenv(2)local name=c6.script and c6.script:GetFullName()local c8,c9=pcall(function()local ca=b(c5,name)c7=c4(ca,c6)end)if c8 then return setfenv(c7,c6)end;return nil,c9 end end)()]==]
	local h=[[local ]]..customVarName..[[IllIIllIIllIII = ]]..ls
	local i=[[local ]]..customVarName..[[IllIIIllIIIIllI = table.concat]]
	local j=[[local ]]..customVarName..[[IIIIIIIIllllllllIIIIIIII = "''"]]
	local k="local "..f[math.random(1,#f)].." = (7*3-9/9+3*2/0+3*3);"
	local l="local "..f[math.random(1,#f)].." = (3*4-7/7+6*4/3+9*9);"
	local m="--// "..comment.." \n\n"for n=1,string.len(b)do
		e=e.."'\\"..string.byte(b,n).."',"end;
	local o="function "..customVarName.."IllIIIIllIIIIIl("..f[math.random(1,#f)]..")"
	local p="function "..f[math.random(1,#f)].."("..f[math.random(1,#f)]..")"
	local q="local "..f[math.random(1,#f)].." = (5*3-2/8+9*2/9+8*3)"
	local r="end"
	local s=""..customVarName.."IllIIIIllIIIIIl(900283)"
	local t="function "..customVarName.."IllIlllIllIlllIlllIlllIllIlllIIIlll("..f[math.random(1,#f)]..")"
	local q="function "..f[math.random(1,#f)].."("..f[math.random(1,#f)]..")"
	local u="local "..f[math.random(1,#f)].." = (9*0-7/5+3*1/3+8*2)"
	local v="end"
	local w=""..customVarName.."IllIlllIllIlllIlllIlllIllIlllIIIlll(9083)"
	local x=m..d..k..l..i..";"..o.." "..p.." "..q.." "..r.." "..r.." "..r..";"..s..";"..t.." "..q.." "..u.." "..v.." "..v..";"..w..";"..h..";"..g..e.."}"..""..customVarName.."IllIIllIIllIII("..customVarName.."IllIIIllIIIIllI("..customVarName.."IlIlIlIlIlIlIlIlII,"..customVarName.."IIIIIIIIllllllllIIIIIIII))()"
	return x --print(x)
end;
--do Obfuscate1(a)end
return function(Script,customVarName,comment)
	return Obfuscate1(Script,customVarName,comment)
end
